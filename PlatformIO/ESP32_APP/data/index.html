<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link id="favicon" rel="shortcut icon" type="image/png"
    href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFM0lEQVR4nO2a2W9VVRTGf61BRaW0Di++iLTw5IDDg1ERp2g0mjhQVBK1ElBwqmjC4JM4NTxo9B+oGJ8cMCZiEHGWiAoiDikyqC8OlRrEgoJYe8xKvk1WNueec+695xZq+JKT9J717XXOOntYa3+7cBiFMV7XqEE7MAdYBnwK7ACS6Nohm3Fmq80hgTZgPvBFyksXvTYAD8jXiOMEYCkw6F7I/h5yv18ELnS/pwIvud9DUfs/gJ6RCqgJmAUMuBd4E7gZWKzffwG3uTaBF3A7sEf3rM0twCrH2w506VkNwfHAa+6BHwIXyHYx8A8wDEyP2sWBGDrFtTbTdM967yPHf7URvTMZ+N4NIfuqAWOATbI9ktI2LRDDo7q/ST4CrDd2ybYN6CgriLOAX+V4fYrjB2X7FjiyikCMu1k28+ExCfhcNnv2lDJ6IgTxLnBcZB+rMW32qyr4qBSI4Wo3L8yXxzjgfRdMzT3T5oZTH3BMCudO2b/M8JMVCGqbKK/EONYN261AK1WiKZrYYejcEzn7RLZ5dQQyT/a17t543Q9DL1zLq13NZrmJvRD4zjnbp+VyseO01BFIi5vcC4A3gL2unfXEQy7n+IUmN9kNRF/6CC2rqxSI/0q7df9ZYC5wJXAuMFG9F3ituneOOHcBTwMrXSCJS5artUzbs9FoCPOl0LK8VA0+AJor5JMuN8nLvAZUr52Y8txml2esAshEm+vCkOzSYON0p3jnAddoWPTqS67XQvG7e8mdumfL6tsqHBcB1wHnO05TxnOnunIms1dCTliTE/Ak8X4kH3lzJOBn8fIq4o/F684ihSr2hhxnneK9XmIgK8SbXvDZ1uupaBfhT+DoHGc94i4pMZDHxHsihzdWhalxJ6QR5shoXyYPy8WdUWIgVkEb7+UC3JXiWpo4AM/LeF8BR6F0uKTEQC51pVAeusV9Ls34mYxWkufhG3FPKzGQM8T7qgD38pRqYD/CHvvUKlaYk0sMxHwl8p2HMJ9/S0s2w8qofm9QCX/LUVrZXmsg5mtYvvPqqTF613/jpN3SgCw9Ute4/2UgzTUOraNKHFrmK1HlS61Da7RN9omVJjtSAIsuv1+Le3qJgZxZYLcZcJm4VncdgGWjMCH2phlny2g7tDy8Iu5Nh2KJ0u6KxljRiPGkuKZNHcyi8ZRKpA0i3FiwlF5RYiA2Eqop49dlkeaLZHVXFjrE+6nEQH4Rz1akLKwV7/4sUpu2kYm02CJbXdumXi9V5QVNVtug/eA4lba6tj2+VtvlwMkqTy5yvFyNq8eJ1Gniw0nau3hFvqxru4QNEzhiNGsLXmQe7e+VoJCYBIMkGdtEvROdgSSScmwVeUoBWol9thJrJTnoCslBz0hK2h353Ae8FclB98rWX43i2KVGgxLHtrqH7NUkX+ACqVegG1SJtEjnLaEESiQOLnTqzq1UgSadT8SS6dzopRslmbYCd+uZ/h2K5JjUIbbNidgmKFcSsTfWEcjGHBG7T/Yt9ZwOd7hjhffikrnBxwotrhTqL+MEeIocJUqYJs6liXqb6zjosfzlMdlpbP0qKEtBhxtmu7QYpB29LakikFCS9EV7oDucqL2lEWfxrU7PSrSmh6Q5zR2GdhYIZIY7DLUkF3TdNdHEbth/TDTpfCLMm0Tr/UzgYf3eE/VYHEhXdDw9U8J34PVXu8TWgzZVAKGcSfT3UPRF438YCOV/pX8YeLyW47WyAuqWoFxrWbJOPg5KAGmYoI1OrxJlWi02oMTXK27F/cShiJacEuYwcPgPknvUyL7T8dYAAAAASUVORK5CYII=">

<head>

    <script src="/ko.js"></script>
    <script src="/toast.js"></script>

    <script type="text/javascript">
        function init() {
            if (ko) {
                document.getElementById("main-app").style.display = "block";
                document.getElementById("ko-js-error").style.display = "none";
                const mainViewModel = new MainViewModel();
                ko.applyBindingsToDescendants(mainViewModel, document.getElementById("main-app"));
                mainViewModel.afterInit();
            }
        }
    </script>
<style>
.spining-loader-container {
    width: 50px;
    margin-left: auto;
    margin-right: auto;
    margin-top: 100px;
}

.spining-loader {
    width: 50px;
    aspect-ratio: 1;
    border-radius: 50%;
    border: 8px solid;
    border-color: #000 #0000;
    animation: spining-loader-frames 1s infinite;
}

@keyframes spining-loader-frames {
    to {
        transform: rotate(.5turn)
    }
}



.bar-loader {
    width: 45px;
    aspect-ratio: .75;
    --c: no-repeat linear-gradient(#000 0 0);
    background:
        var(--c) 0% 100%,
        var(--c) 50% 100%,
        var(--c) 100% 100%;
    background-size: 20% 65%;
    animation: bar-loader-frames 1s infinite linear;
}

@keyframes bar-loader-frames {
    20% {
        background-position: 0% 50%, 50% 100%, 100% 100%
    }

    40% {
        background-position: 0% 0%, 50% 50%, 100% 100%
    }

    60% {
        background-position: 0% 100%, 50% 0%, 100% 50%
    }

    80% {
        background-position: 0% 100%, 50% 100%, 100% 0%
    }
}
</style>
<style>
table {
    border-collapse: collapse;
    width: 100%;
}

th,
td {
    text-align: left;
    padding: 12px 5px;
}

tr:nth-child(even) {
    background-color: #D6EEEE;
}

.menu-container {
    display: flex;
    justify-content: space-between;
    padding: 5px;
    background-color: #C5CEFF;
}

.app-container {
    padding: 5px;
    background-color: #FFDB8657;
    width: 100%;

}

.active-menu-container {}

html {
    height: 100%;
}

body {
    min-height: 100%;

    display: flex;
    align-items: stretch;
}
</style>
<style>
.my-toastify-card {
    color: black !important;
    background-color: white !important;
    background: white !important;
    border-style: solid !important;

    border-top: 1px black;
    border-left: 1px black;
    border-right: 1px black;
    border-bottom: 1px black;
}

.my-toastify-card.danger {
    border-left: 5px solid #b00000 !important;
    border-top: 1px solid #b00000 !important;
    border-right: 1px solid #b00000 !important;
    border-bottom: 1px solid #b00000 !important;
}


.my-toastify-card.success {
    border-left: 5px solid #198603 !important;
    border-top: 1px solid #198603 !important;
    border-right: 1px solid #198603 !important;
    border-bottom: 1px solid #198603 !important;
}


.my-toastify-card.info {
    border-left: 5px solid #200386 !important;
    border-top: 1px solid #200386 !important;
    border-right: 1px solid #200386 !important;
    border-bottom: 1px solid #200386 !important;
}

.my-toastify-card button {
    color: black !important;
}
</style>
<style>
/*!
 * Toastify js 1.12.0
 * https://github.com/apvarun/toastify-js
 * @license MIT licensed
 *
 * Copyright (C) 2018 Varun A P
 */

 .toastify {
    padding: 12px 20px;
    color: #ffffff;
    display: inline-block;
    box-shadow: 0 3px 6px -1px rgba(0, 0, 0, 0.12), 0 10px 36px -4px rgba(77, 96, 232, 0.3);
    background: -webkit-linear-gradient(315deg, #73a5ff, #5477f5);
    background: linear-gradient(135deg, #73a5ff, #5477f5);
    position: fixed;
    opacity: 0;
    transition: all 0.4s cubic-bezier(0.215, 0.61, 0.355, 1);
    border-radius: 2px;
    cursor: pointer;
    text-decoration: none;
    max-width: calc(50% - 20px);
    z-index: 2147483647;
}

.toastify.on {
    opacity: 1;
}

.toast-close {
    background: transparent;
    border: 0;
    color: white;
    cursor: pointer;
    font-family: inherit;
    font-size: 1em;
    opacity: 0.4;
    padding: 0 5px;
}

.toastify-right {
    right: 15px;
}

.toastify-left {
    left: 15px;
}

.toastify-top {
    top: -150px;
}

.toastify-bottom {
    bottom: -150px;
}

.toastify-rounded {
    border-radius: 25px;
}

.toastify-avatar {
    width: 1.5em;
    height: 1.5em;
    margin: -7px 5px;
    border-radius: 2px;
}

.toastify-center {
    margin-left: auto;
    margin-right: auto;
    left: 0;
    right: 0;
    max-width: fit-content;
    max-width: -moz-fit-content;
}

@media only screen and (max-width: 360px) {
    .toastify-right, .toastify-left {
        margin-left: auto;
        margin-right: auto;
        left: 0;
        right: 0;
        max-width: fit-content;
    }
}

</style>

<script type="text/javascript">
class AjaxHandler {
    constructor() {

    }

    async dealay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async scanWifi() {
        const response = await this.scanWifiNetworks();        
        if (response == "OK") {
            let hasResult = false;
            while (!hasResult) {
                const results = await this.scanWifiNetworkResults()
                if (results && results.networks && results.networks.length > 0) {
                    hasResult = true;
                    return results;
                }
                await this.dealay(1000);
            }
        }
    }

    async scanWifiNetworks() {
        const response = await fetch('/scan-wifi', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        return response.text();
    }

    async connectionInfo() {
        const response = await fetch('/connection-info', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        return response.json();
    }

    

    async scanWifiNetworkResults() {
        const response = await fetch('/scan-wifi-result', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        //console.log(response);
        return response.json();
    }

    async settings() {
        const response = await fetch('/settings', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        return response.json();
    }

    async connectoToNetwork(ssid, password) {
        const response = await fetch('/connect-wifi', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                ssid: ssid,
                password: password
            })
        });
        //console.log(response);
        return response.json();
    }

    async saveSettings(settings) {
        const response = await fetch('/settings', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(settings)
        });
        //console.log(response);
        return response.json();
    }
}


</script>
<script type="text/javascript">
class ConnectionInfoViewModel {
    constructor(ajaxHandler) {

        this.ajaxHandler = ajaxHandler;
        this.doConnectionPolling = ko.observable(false);

        this.afterMenuRequested = () => { };

        this.startPolling = () => {
            console.log("start polling");
            this.doConnectionPolling(true);
        }

        this.stopPolling = () => {
            console.log("stop polling");
            this.doConnectionPolling(false);
        }

        this.ipAddress = ko.observable('');
        this.rssi = ko.observable(null);
        this.last_status = 6
        this.status = ko.observable(6);

        this.hasIpAddress = ko.pureComputed(() => {
            if (this.doConnectionPolling() && this.ipAddress()) {
                return true;
            }
            return false;
        }, this);

        ko.computed(() => {
            if (this.doConnectionPolling()) {
                this.startPolling();
            }
            else {
                this.stopPolling();
            }
        }, this);

        this.inPoll = false;

        this.getStatusText = () => {
            switch (this.status()) {
                case 0: return "No Shiled";//"WL_NO_SHIELD";
                case 1: return "Idle";//"WL_IDLE_STATUS";
                case 2: return "No SSID avaliable";//"WL_NO_SSID_AVAIL";
                case 3: return "Connected";//"WL_CONNECTED";
                case 4: return "Connection Failed";//"WL_CONNECT_FAILED";
                case 5: return "Connection Lost";//"WL_CONNECTION_LOST";
                case 6: return "Disconnected";//"WL_DISCONNECTED";
                default: return "UNKNOWN";
            }
        }

        this.getInfo = () => {
            this.ajaxHandler.connectionInfo().then((response) => {
                this.ipAddress(response.ip);
                this.rssi(response.rssi);
                this.status(response.status);

                if (this.last_status !== response.status && response.status !== 3 /*WL_CONNECTED*/) {
                    toast(`Connection status: ${this.getStatusText()}`, "danger", true);
                }
                this.last_status = response.status;

            }).catch((e) => {
                toast_error("connection-status-pooller connectionInfo", e, true);
            }).finally(() => {
                this.inPoll = false;
            });
        }

        const interval = setInterval(() => {
            const doPolling = this.doConnectionPolling();
            if (doPolling) {
                try {
                    if (!this.inPoll) {
                        this.inPoll = true;
                        this.getInfo();
                    }
                } catch (error) {
                    toast_error("connection-status-pooller", e, true);
                    this.inPoll = false;
                }
            }
        }, 5000);

        this.killTimer = () => {
            clearInterval(interval);
        }

        this.getInfo();
    }
};
</script>
<script type="text/javascript">
class MainViewModel {
    constructor() {

        this.ajaxHandler = new AjaxHandler();
        this.connectionInfo = new ConnectionInfoViewModel(this.ajaxHandler);

        this.menu = {
            home: {
                templateName: 'menu-home',
                viewModel: new MenuHomeViewModel()
            },
            connectToWifi: {
                templateName: 'menu-connect-to-wifi',
                viewModel: new MenuConnectToWifiViewModel(this.ajaxHandler, this.connectionInfo)
            },
            settings: {
                templateName: 'menu-settings',
                viewModel: new MenuSettingsViewModel(this.ajaxHandler, this.connectionInfo)
            },
            connectionInfo: {
                templateName: 'menu-connecion-info',
                viewModel: this.connectionInfo
            },
        }

        this.activeMenuTemplateName = ko.observable(null);
        this.activeMenuViewModel = ko.observable(null);


        this.setMenu = (menuItem) => {
            this.activeMenuTemplateName('menu-empty');
            this.activeMenuViewModel(menuItem.viewModel); //set VM first!!!
            this.activeMenuTemplateName(menuItem.templateName);

            menuItem.viewModel.afterMenuRequested();
        }

        this.setMenu(this.menu.home);

        this.afterInit = () => {

        }

    }


};
</script>
<script type="text/javascript">
class MenuConnectToWifiViewModel {
    constructor(ajaxHandler, connectionInfo) {
        this.ajaxHandler = ajaxHandler
        this.connectionInfo = connectionInfo;

        this.ajaxHandler = ajaxHandler
        this.scanWifiNetworksButtonDisable = ko.observable(false);
        this.isTryToConnectToWifi = ko.observable(false);
        this.lastScanResults = ko.observableArray([]);
        this.isLoaderVisible = ko.observable(false);

        this.transformWifiScanResultToViewModel = (response, onConnectCallback) => {
            if (response && response.networks && response.networks.length > 0) {

                const resultLookup = {}
                response.networks.forEach(network => {
                    const key = network.SSID + "_" + network.EncryptionType;
                    if (!resultLookup[key]) {
                        resultLookup[key] = network;
                    } else {
                        if (parseInt(network.RSSI) > parseInt(resultLookup[key].RSSI)) {
                            resultLookup[key] = network;
                        }
                    }
                });

                return Object.values(resultLookup).map((scanResult) => new WifiNetworkListItem(scanResult, onConnectCallback));
            }
            return [];
        }

        this.scanWifiNetworks = async () => {
            try {
                this.isLoaderVisible(true);
                this.lastScanResults.removeAll();
                this.scanWifiNetworksButtonDisable(true);
                this.isTryToConnectToWifi(false);
                const response = await this.ajaxHandler.scanWifi();
                this.lastScanResults(this.transformWifiScanResultToViewModel(response, this.onConnectCallback));
            }
            catch (e) {
                toast_error("scanWifiNetworks", e);
            }
            finally {
                this.isLoaderVisible(false);
                this.scanWifiNetworksButtonDisable(false);
                this.isTryToConnectToWifi(false);
            }
        };

        this.onConnectCallback = async (ssid, encryptionType) => {            
            let password = "";
            if (encryptionType !== "None") {
                password = prompt("Please enter the password for " + ssid, "");
            }
            if (password !== null) {
                this.isTryToConnectToWifi(true);
                this.lastScanResults.removeAll();

                try{
                    await this.ajaxHandler.connectoToNetwork(ssid, password)                    
                    this.connectionInfo.doConnectionPolling(true);
                }catch(e){

                }
                finally{
                    this.isTryToConnectToWifi(false);
                }
            }
        }

        this.afterMenuRequested = () => {
            this.scanWifiNetworks();
        }
    }
};
</script>
<script type="text/javascript">
class MenuHomeViewModel {
    constructor() {
        this.afterMenuRequested = () => { };
    }
};
</script>
<script type="text/javascript">
class MenuSettingsViewModel {
    constructor(ajaxHandler, connectionInfo) {
        this.ajaxHandler = ajaxHandler
        this.connectionInfo = connectionInfo;
        this.isLoaderVisible = ko.observable(false);


        this.ap_ssid = ko.observable('');
        this.ap_password = ko.observable('');
        this.connect_to_ssid = ko.observable('');
        this.connect_to_password = ko.observable('');

        this.getSettings = async () => {
            this.isLoaderVisible(true);
            try {
                const response = await this.ajaxHandler.settings();
                this.ap_ssid(response.ap_ssid);
                this.ap_password(response.ap_password);
                this.connect_to_ssid(response.connect_to_ssid);
                this.connect_to_password(response.connect_to_password);

                if (response.connect_to_ssid) {
                    this.connectionInfo.doConnectionPolling(true);
                }
            }
            catch (e) {
                toast_error("getSettings", e);
            }
            finally {
                this.isLoaderVisible(false);
            }
        }

        this.onRefreshSettingsClicked = async () => {
            await this.getSettings()
        }

        this.onDisconnectClicked = async () => {
            this.connect_to_password(null);
            this.connect_to_ssid(null);
            await this.onSaveSettingsClicked();
        }


        this.onSaveSettingsClicked = async () => {
            await this.ajaxHandler.saveSettings({
                ap_ssid: this.ap_ssid() || null,
                ap_password: this.ap_password() || null,
                connect_to_ssid: this.connect_to_ssid() || null,
                connect_to_password: this.connect_to_password() || null
            });

            if (this.connect_to_ssid() || null) {
                this.connectionInfo.doConnectionPolling(true);
            }
            else {
                this.connectionInfo.doConnectionPolling(false);
            }

        }

        this.getSettings();

        this.getPasswordInputType = (isVisible) => {
            return isVisible ? 'text' : 'password';
        }

        this.connect_to_password_visible = ko.observable(false);
        this.connect_to_password_type_attr = ko.pureComputed(() => {
            return this.getPasswordInputType(this.connect_to_password_visible());
        }, this);

        this.ap_password_visible = ko.observable(false);
        this.ap_password_type_attr = ko.pureComputed(() => {
            return this.getPasswordInputType(this.ap_password_visible());
        }, this);

        this.afterMenuRequested = () => {
            this.getSettings();
        }
    }
};
</script>
<script type="text/javascript">


toast = function (text, type, autoHide = true, hasCloseButton = true) {
    console.log(`toast: ${text}`);
    Toastify({
        text,
        duration: autoHide ? 5000 : -1,
        newWindow: false,
        close: hasCloseButton,
        gravity: "top", // `top` or `bottom`
        position: "right", // `left`, `center` or `right`
        stopOnFocus: true, // Prevents dismissing of toast on hover                    
        className: `my-toastify-card ${type}`,
        onClick: function () { } // Callback after click
    }).showToast();
}

toast_error = function (from, exception, autoHide = false) {
    console.error(exception);
    toast(`ERROR (at ${from})\n${exception.message || exception.toString()}`, "danger", autoHide, true);
}
</script>
<script type="text/javascript">
class WifiNetworkListItem {
    constructor(scanResult, onConnectCallback) {
        this.ssid = scanResult.SSID;
        this.rssi = parseInt(scanResult.RSSI);
        this.encryptionType = scanResult.EncryptionType;
        this.onConnectClick = async () => {
            if (onConnectCallback) {
                await onConnectCallback(this.ssid, this.encryptionType);
            }
        }
    }
}
</script>

<script type="text/html" id="connection-indicator">
<div style="display: inline-block;">

    <div style="display: inline-block;" data-bind="if: doConnectionPolling() && hasIpAddress()">
        Connected: &nbsp;
        <span style="display: inline-block;" data-bind="text:ipAddress"></span>
    </div>


    <div style="display: inline-block;" data-bind="if: doConnectionPolling() && !hasIpAddress()">
        Connecting... &nbsp;
        <div class="bar-loader" style="display: inline-block; width: 10px;"></div>
    </div>

    <div style="display: inline-block;" data-bind="ifnot: doConnectionPolling">
        No Connection configured;
    </div>

</div>
</script>
<script type="text/html" id="menu-connecion-info">
<div>
    Connection info
</div>


<div>
    IP Address: <span data-bind="text:ipAddress"></span>
</div>
<div>
    Signal strength:
    <div style="display: inline-block;" data-bind="if: rssi()!==null">
        <div style="display: inline-block;" data-bind=" template: { name: 'wifi-network-rssi-value', data: rssi }">
        </div> (<span data-bind="text:rssi"></span> dBm)
    </div>
</div>

<div>
    Status:
    <span data-bind="text:getStatusText()"></span>
</div>
</script>
<script type="text/html" id="menu-connect-to-wifi">
<div>
    <button data-bind='click: scanWifiNetworks, disable: scanWifiNetworksButtonDisable'>scanWifiNetworks</button>
</div>


<div data-bind="if: isLoaderVisible">
    <div class="spining-loader-container">
        <div class="spining-loader"></div>
    </div>    
</div>
<div data-bind="ifnot: isLoaderVisible">
    <div data-bind="ifnot: isTryToConnectToWifi">
        <table>
            <thead>
                <tr>
                    <th>SSID</th>
                    <th>Signal</th>
                    <th>Encryption Type</th>
                    <th></th>
                </tr>
            </thead>
            <tbody data-bind="foreach: lastScanResults">
                <tr data-bind="template: { name: 'wifi-network-list-item', data: $data }"></tr>
            </tbody>
        </table>
    </div>
    <div data-bind="if: isTryToConnectToWifi">
        Trying to connect to wifi network...
    </div>
</div>
</script>
<script type="text/html" id="menu-empty">
<div></div>

</script>
<script type="text/html" id="menu-home">
<div>ESP 32 wifi-selector sample app</div>

<div>
    v1.1.1
</div>
</script>
<script type="text/html" id="menu-settings">
<div>Settings</div>
<div data-bind="if: isLoaderVisible">
   <div class="spining-loader-container">
      <div class="spining-loader"></div>
   </div>
</div>
<div data-bind="ifnot: isLoaderVisible">
   <div>
      <button data-bind='click: onRefreshSettingsClicked'>Refresh</button>
   </div>

   <div>
      <label for="ap_ssid">AP SSID:</label>
      <input type="text" id="ap_ssid" data-bind="value: ap_ssid" />
   </div>

   <div>
      <label for="ap_password">AP Password:</label>
      <input id="ap_password" data-bind="value: ap_password, attr: { type: ap_password_type_attr }" />
      <input type="checkbox" id="ap_password_visible" data-bind="checked: ap_password_visible" />
   </div>

   <div>
      <button data-bind='click: onDisconnectClicked'>Disconnect and forget Wifi</button>
   </div>

   <div>
      <label for="connect_to_ssid">Network to connect SSID:</label>
      <input type="text" id="connect_to_ssid" data-bind="value: connect_to_ssid" />
   </div>


   <div>
      <label for="connect_to_password">Network to connect Password:</label>
      <input id="connect_to_password"
         data-bind="value: connect_to_password, attr: { type: connect_to_password_type_attr }" />
      <input type="checkbox" id="connect_to_password_visible" data-bind="checked: connect_to_password_visible" />
   </div>

   <div>
      <button data-bind='click: onSaveSettingsClicked'>Save</button>
   </div>
</div>
</script>
<script type="text/html" id="wifi-network-list-item">
<td data-bind="text: ssid"></td>            
<td style="width: 50px;" data-bind="template: { name: 'wifi-network-rssi-value', data: rssi }"></td>
<td data-bind="text: encryptionType" style="width: 150px;"></td>        
<td style="width: 50px;"><button style="height: 30px;" data-bind="click:onConnectClick">Connect</button></td> 
</script>
<script type="text/html" id="wifi-network-rssi-value">
<!-- ko if: $data >= -30 -->
<span>Amazing</span>
<!-- /ko -->

<!-- ko if: -70 <= $data &&  $data < -30 -->
<span>Excellent</span>
<!-- /ko -->

<!-- ko if: -85 <= $data && $data < -70 -->
<span>Good</span>
<!-- /ko -->

<!-- ko if: -100 <= $data && $data < -85 -->
<span>Fair</span>
<!-- /ko -->

<!-- ko if: $data < -100 -->
<span>Poor</span>
<!-- /ko -->
</script>

</head>

<body onload="init()">
    <div class="app-container" id="main-app" style="display: none;">
        <div class="menu-container">
            <div class="menu-container">
                <button data-bind="click: ()=>{setMenu(menu.home)}">Home</button>
                <button data-bind="click: ()=>{setMenu(menu.connectToWifi)}">Connect To WiFi</button>
                <button data-bind="click: ()=>{setMenu(menu.connectionInfo)}">Connection Info</button>
            </div>           
            <div data-bind="template: { name: 'connection-indicator', data: connectionInfo }"></div>
            <button data-bind="click: ()=>{setMenu(menu.settings)}">Settings</button>
        </div>
        <div class="active-menu-container"
            data-bind="template: { name: activeMenuTemplateName, data: activeMenuViewModel }"></div>
    </div>    
    <div id="ko-js-error" style="display: block;">
        knockout.js is not loaded...
    </div>
</body>

</html>